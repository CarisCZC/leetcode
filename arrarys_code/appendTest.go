// 测试append在向一个二维数组n中添加数组a时，会出现修改a的时候导致n中的值也被修改

package main

func main() {
	n := [][]int{}
	a := []int{1, 2, 3, 4, 5, 6, 7}
	test(&n, a)
}

// append 会扩充数组，当append的数组不扩充时，此时append加入的就是地址
// 当添加的数组a的len<cap,但len~cap位置上原本有值的时候，新的append会覆盖原本len位置上的值
// 而且，会将此影响施加在所有添加了a的数组上！
// 比如，这个测试用例中，第一次添加的a是{1，2，3，4，5，6，6}，该元素为n[0]
// 第二次循环时，首先a修改成了{1，2，3，4，5}
// 然后a添加了5，a变成{1，2，3，4，5，5}
// 注意：在第一次a的这个位置上，是6，此时进行了覆盖，这个覆盖会影响n[0],及n[0] = {1,2,3,4,5,5,6}
// 这是将a加入n，n[1] = {1，2，3，4，5，5}
// 以此类推，会逐层影响
// 因此，在添加a之前（如果在后续a会被修改），那么最好对a进行copy得到newA，将newA 添加到n中
func test(n *[][]int, a []int) {
	for i := len(a) - 1; i > 0; i-- {
		a := a[:i]
		a = append(a, i)
		*n = append(*n, a)
	}
}
